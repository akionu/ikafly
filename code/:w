#include "log.hpp"
Logging::Logging() {
}

bool Logging::init() {
    bool ret = false;
    uint32_t n = 0;
    fsdata_offset   = (uint32_t*)&fsdata[n];
    n += sizeof(uint32_t)*MAX_FILE;
    fsdata_head     = (uint32_t*)&fsdata[n]; 
    n += sizeof(uint32_t)*MAX_FILE;
    fsdata_max_size = (uint32_t*)&fsdata[n]; 
    n += sizeof(uint32_t)*MAX_FILE;
    fsdata_name     = &fsdata[n];
    file_num_head = 0;
    ret = flashMutex_init();
    return ret;
}

bool Logging::mount() {
    bool ret = false;
    // restore fs data from flash
    read(fs_n, fsdata, filesys_size);
    if (std::memcmp(&fsdata_name[fs_n], "filesys", 7) == 0) {
        ret = true;
    } else {
        unmount();
        ret = false;
    }
    return ret;
}

bool Logging::unmount() {
    file_num_head = 0;
    memset(fsdata, 0, filesys_size);
    return true;
}

bool Logging::make(uint8_t* file_num, const char name[8], const uint8_t size_name, const uint32_t max_size) {
    const uint8_t fnum = file_num_head;
    // offset
    if (fnum == 0) fsdata_offset[fnum] = offset_base;
    else           fsdata_offset[fnum] = offset_base + fsdata_offset[fnum-1] + fsdata_max_size[fnum-1];
    // head
    fsdata_head[fnum] = 0;
    // max_size
    fsdata_max_size[fnum] = max_size;
    // name
    memcpy((void*)&fsdata_name[MAX_NAME_LEN*fnum], name, 8);
    
    *file_num = fnum;

    return true; 
}

bool Logging::find(uint8_t* file_num, const char query_name[8], const uint8_t size_query_name) {
    return true;
}

bool Logging::read(const uint8_t file_num, const void* buf, const uint32_t size) {
    bool ret = false;
    ret = read_page(fsdata_offset[file_num], (uint8_t*)buf, size);
    return ret;
}

bool Logging::write(const uint8_t file_num, const void* buf, const uint32_t size) {

}

bool Logging::append(const uint8_t file_num, const void* buf, const uint32_t size) {
    return true;
}

void Logging::erase(const uint8_t file_num, const uint32_t size) {
    fsdata_head[file_num] = 0;
}

bool Logging::nuke() {
    bool ret = false;
    ret = erase_sector_safe(offset_base, FLASH_SECTOR_SIZE);
    return ret;
}

bool Logging::save_fs_force() {
     
}

//private:
bool Logging::write_less_than_page_safe(const uint32_t offset, uint8_t* buf, uint32_t size) {

}

bool Logging::write_page_internal_safe(const uint32_t offset, uint8_t* buf, uint32_t size) {

bool Logging::flashMutex_init() {
    flashMutex = xSemaphoreCreateMutex();
    return (flashMutex != NULL);
}

bool Logging::flashMutex_lock() {
    return (xSemaphoreTake(flashMutex, (TickType_t)20) == pdTRUE);
}

bool Logging::flashMutex_unlock() {
    return (xSemaphoreGive(flashMutex) == pdTRUE);
}

void Logging::erase_sector_unsafe(void *p) {
    struct flash_ew_t* fp = (struct flash_ew_t*)p;
    flash_range_erase(fp->offset, fp->size); // FLASH_SECTOR_SIZE == 4096Byte defined in flash.h
}

void Logging::write_page_unsafe(void *p) {
    struct flash_ew_t* fp = (struct flash_ew_t*)p;
    flash_range_program(fp->offset, fp->buf, FLASH_PAGE_SIZE);
}

bool Logging::erase_sector_safe(const uint32_t offset, uint32_t size) {
    //    printf("erase_sector_safe: offset: 0x%02x, size: 0x%02x\n", offset, size);
    struct flash_ew_t f = {
        .offset = offset,
        .size = size
    };
    if (flashMutex_lock()) {
        int8_t ret = flash_safe_execute(Logging::erase_sector_unsafe, (void*)&f, UINT32_MAX);
        printf("locked, ret: %d ", ret);
        return (flashMutex_unlock() && (PICO_OK == ret));
    }
    return false;
}

bool Logging::write_page_safe(const uint32_t offset, uint8_t* buf) {
    struct flash_ew_t f = {
        .offset = offset,
        .buf    = buf
    };
    if (flashMutex_lock()) {
        int8_t ret = flash_safe_execute(Logging::write_page_unsafe, (void*)&f, UINT32_MAX);
        //		printf("locked, ret: %d ", ret);
        return (flashMutex_unlock() && (PICO_OK == ret));
    }
    return false;
}

void Logging::read_page(const uint32_t offset, uint8_t* buf, uint32_t size) {
    if (flashMutex_lock()) {
        const uint8_t *p = (const uint8_t *)(XIP_BASE + offset);
        memcpy(buf, p, size);
        return (flashMutex_unlock());
    }
    return false;
}

uint32_t Logging::swap(uint32_t dat) {
    char out[4],*p = (char*)&dat;
    out[3] = *p++;
    out[2] = *p++;
    out[1] = *p++;
    out[0] = *p++;
    return *(uint32_t*)out;
}

uint8_t* Logging::fsdata_get_name(uint8_t file_num) {
    return (&fsdata_name[MAX_NAME_LEN*file_num]);
}
